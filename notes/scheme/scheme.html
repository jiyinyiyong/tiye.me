			<title>			scheme笔记			</title>			<meta charset='utf-8'/>			<style>			body{
	background: hsl(0,96%,96%);
	font-size: 13px;
	padding: 26px 130px;
	line-height: 26px;
}
body>code, pre{
	padding: 0px 3px;
	margin: 0px 3px;
	background: hsl(0,94%,95%);
	border: 1px solid hsl(0,96%,86%);
}
p{
	margin: 0px;
}
pre{
	-moz-tab-size: 4;
	margin: 0px;
	width: 600px;
}
body>*{
	margin: 0px;
}
a{
	color: hsl(240,40%,50%);
	text-decoration: none;
}			</style>			<br/>打算学<code>Scheme</code>, 搜了不少尝试去理解, 中文资源不如<code>JS</code>多<br/><code>IBM</code>社区<code>5+</code>篇文章, 下面两篇介绍语法方面比较清晰<br/><a href='http://www.ibm.com/developerworks/cn/linux/l-schm/index1.html'>www.ibm.com/developerworks/cn/linux/l-schm/index1.html</a><br/><a href='http://www.ibm.com/developerworks/cn/linux/l-schm/index2.html'>www.ibm.com/developerworks/cn/linux/l-schm/index2.html</a><br/>关于历史掌故可以看下面这篇了解下, 比较乱, 我没有细看<br/><a href='http://blog.chinaunix.net/space.php?uid=20106293&do=blog&id=142113'>blog.chinaunix.net/space.php?uid=20106293&do=blog&id=142113</a><br/><code>scm</code>的规范简介有力, 真的很短, 入门后去看下<br/>直接<code>Google</code>就能找到 "算法语言<code>Scheme</code>修订<code>5</code>报告"<br/>教程英文的不少, 中文有本<code>SICP</code>的翻译, 算清晰, 爱问搜索有<br/>我搜到<code>3</code>份英文教程, 打算只看最简短的第一份了<br/><code>Teach Yourself Scheme in Fixnum Days</code><br/><a href='http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme-Z-H-1.html'>www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme-Z-H-1.html</a><br/><code>How to Design Programs: DrScheme Companion</code> <a href='http://www.htdp.org/'>www.htdp.org/</a><br/><code>The Scheme Programming Language</code> <a href='http://www.scheme.com/tspl3/'>www.scheme.com/tspl3/</a><br/>我参照的这份文档只为学会用 scm 解决问题, 大不算深入<br/>然后我很想用上<code>Scheme</code>的缩进语法, 希望入门后去看 <br/><a href='http://srfi.schemers.org/srfi-49/srfi-49.html'>srfi.schemers.org/srfi-49/srfi-49.html</a><br/><br/>记得例子不少用<code>guile</code>来运行<code>scm</code>的, 在脚本开头加两行并可以空行<br/><pre><code>#! /usr/bin/env guile<br/>!#</code></pre>系统没有 guile 可以在 Ubuntu 安装, 我装的是 1.8 版本<br/>然后脚本我不重复了, 开头缩进是笔记格式, 代码参考原文<br/><pre><code>;The first program<br/>(begin<br/>	(display "Hello")<br/>	(newline))</code></pre>分号开头进行注释, <code>begin</code>表示后边多个模式<br/><code>display</code>是向<code>console</code>输出, <code>newline</code>是输出新的换行<br/>教程说的<code>mzscheme</code>不清楚, <code>Ubuntu</code>里面用的<code>guile</code><br/>实际上我用的命令是<code>$ rlwrap guile</code><br/>然后输入<code>load "hi.scm"</code>(点钱目录文件名)运行该脚本<br/><code>guile</code>中的<code>prompt</code>是<code>guile&gt;</code>, 这里直接输入代码<br/>在<code>prompt</code>中输入<code>"hi"</code>会直接输出内容<br/>两种方式有区别, 向<code>console</code>输出对于函数是种副作用<br/>而<code>"hi"</code>则是计算得到结果的<br/>文章约定<code>=&gt;</code>表示模式运算后给出结果<br/>可以用<code>(exit)</code>退出<code>guile</code>命令行, <code>Linux</code>常快捷键<code>C^d</code><br/>运行脚本可以用<code>guile -s hi.scm</code><br/><br/><p><b><code>scm</code>有布尔, 数值, 字符, 符号几个数据类型</b></p>真: <code>#t</code>, 假: <code>#f</code>, 判断是否布尔类型: <code>boolean? #t</code><br/>否定: <code>(not #t) ;=&gt; #f</code><br/><code>scm</code>中数值类型有整数, 分数, 实数, 复数<br/>各自有<code>number? complex? real? rational? integer?</code> 判断<br/>整数未必十进制, 前缀<code>#b #o #x</code>分别表示二, 八, 十六进制<br/>比如<code>#b100</code>是二进制的<code>100</code>, 十进制的<code>4</code><br/>判断大小是否相等用<code>(eqv? 2 #b10) =&gt; #t</code><code>(eqv? 2 2.0) =&gt; #f</code><br/>这个广义的判别函数对于不同类型不会报错<code>(eqv? 2 #f) =&gt; #f</code><br/>另外有个针对数值的判别符<code>(= 42 42.0) =&gt; #t</code><br/>而这个判别符对于数值外内容会报错, 比如<code>(= 2 #f)</code><br/>对于数字的大小判断还有<code>&gt; &lt; &gt;= &lt;=</code>可用<br/>运算符号有<code>+ - * /</code>, 都支持一个或多个参数<br/>其中除法结果是分数<br/><code>(expt 2 3)</code>表示乘方, 只有两个参数<br/><code>min max abs exp atan sqrt</code>等都可以推测<br/><code>scm</code>的字符以<code>#\</code>开头比如<code>#\c</code>是字符<code>c</code><br/>一般是在后面跟一个字符, 但也有用多个字母描述的比如<br/><code>#\newline #\tab #\space</code>, 也有<code>#\ </code>表示空格<br/>字符的判别: <code>char? #\c ;=&gt; #t</code>, 字符还有大小的判别<br/><code>char&lt;? char&lt;=? char=? char&gt;=? char&gt;?</code><br/>为忽略大小写用<code>(char-ci=? #\A #\a) =&gt; #t</code>, 以此类推<br/>字母大小写转换用<code>char-downcase char-upcase</code><br/>前面这些比如<code>#t 42 #\c</code>自求值的内容<br/>符号被输入到解释器里, 给出运算结果一般就是本身<br/>符号类型不同, 因为同样的内容常被用作变量标识符<br/>意味着那会被计算, 并返回计算结果的内容<br/>但符号依然是基本的数据类型, 可以和其他类型交换<br/>在<code>scm</code>里用上<code>(quote xyz) =&gt; xyz</code>标记符号<br/>符号非常常用, 于是有了简写<code>'E</code>相当于<code>(quote E)</code><br/>符号的表示以不被混淆为准, <code>&lt;=&gt;</code>和'$!#*'都行<br/>但像这些<code>#t "aString" -i</code>就不行了<br/>可以用<code>(symbol? 'xyz)</code>判别<br/>注意<code>scm</code>里对大小写不敏感, 这里不例外<br/>接着可以定义符号为变量<code>(define xyz 9)</code><br/>在解释器里输入就会直接返回内容了<code>xyz ;=&gt; 9</code><br/>或者用<code>(set! xyz #\c)</code>这样<br/>复合数据类型由数据类型俺结构组合而成<br/>字符串是自求值的<code>"Hello" =&gt; "Hello"</code><br/>该程序由一系列字符组成<code>(string #\H #\e #\l #\l #\o)</code><br/>用<code>(string-ref "abcd" 1)</code>取出序号<code>1</code> 的元素<br/>用<code>(string-append "a" "b" "c")</code>来组合新的字符串<br/>可新建指定长的空字符串<code>(make-string 3) ;=&gt; "\x00\x00\x00")</code><br/>如果<code>(define s (make-string 3))</code><br/>那么再给<code>s</code>赋值就注意不能越界<br/><code>(string-set! s 0 #\s)</code>用来修改指定序号的字符<br/>向量可以容纳各种类型, 包括向量自身<br/>定义向量: <code>(vector 1 2 3) ;=&gt; #(1 2 3)</code><br/>也可以直接使用<code>#(1 2 3)</code>产生向量<br/>类似有<code>(make-vector 5)</code>来生成限定长度的向量<br/>类似有<code>vector-ref vector-set vector?</code><br/><p><b>点对用来组合任意两个值, 前者称<code>car</code>, 后者<code>cdr</code></b></p>组合两者的程序是<code>(cons 1 #\t) ;=&gt; (1 . #\t)</code><br/>简洁的定义的方式<code>'(1 . #\t)</code><br/><pre><code>(define x '(1 . #\t))</code></pre>取出内容通过<code>(car x)</code>或者<code>(cdr x)</code><br/>设置: <code>(set-car! x)</code>和<code>(set-cdr! x)</code><br/><pre><code>(define y (cons (cons 1 2) 3)) ;=&gt; ((1 . 1.0) . 2))<br/>(define y (cons 1 (cons 2 3))) ;=&gt; (1 2 . 3)</code></pre><code>(cdr (car y))</code>可以简化成<code>(cdar y)</code>最多四层<br/><pre><code>(cons 1 (cons 2 (cons 3 (cons 4 5)))) ;=&gt; (1 2 3 4 . 5)</code></pre>有个空的点对<code>'() ;=&gt; ()</code><br/><pre><code>'(1 . (2 . (3 . (4 . ())))) ;=&gt; (1 2 3 4)<br/>(cons 1 (cons 2 (cons 3 (cons 4 '())))) ;=&gt; (1 2 3 4)</code></pre>还有个程序: <code>(list 1 2 3 4) ;=&gt; (1 2 3 4)</code><br/>还有: <code>'(1 2 3 4) ;=&gt; (1 2 3 4)</code><br/><pre><code>(define y (list 1 2 3 4))<br/>(list-ref y 0) ;=&gt; 1<br/>(list-ref y 3) ;=&gt; 3<br/>(list-tail y 1) ;=&gt; (2 3 4)<br/>(list-tail y 3) ;=&gt; (4)<br/>(pair? '(1 . 2)) ;=&gt; #t<br/>(pair? '(1 2)) ;=&gt; #t<br/>(pair? '()) ;=&gt; #f<br/>(list? '()) ;=&gt; #t<br/>(null? '()) ;=&gt; #t<br/>(list? '(1 2)) ;=&gt; #t<br/>(list? '(1 . 2)) ;=&gt; #f</code></pre>字符串和数值间通过<code>ASIIC</code>码互转, 其他较明显<br/><pre><code>(char-&gt;integer #\d) ;=&gt; 100<br/>(integer-&gt;char 50) ;=&gt; #\2<br/>(string-&gt;list "hello") ;=&gt; (#\h #\e #\l #\l #\o)<br/>(number-&gt;string 16) ;=&gt; "16"<br/>(string-&gt;number "16") ;=&gt; 16<br/>(string-&gt;number "hi") ;=&gt; #f<br/>(symbol-&gt;string 'symbol) ;=&gt; "symbol"<br/>(string-&gt;symbol "string") ;=&gt; string</code></pre>基于基数的转化, 比如下面基于八进制<br/><pre><code><code>(string-&gt;number "16" 8)</code></code></pre><code>scm</code>还有个过程类型<code>procedure</code>, 目前看到都是基本过程<br/>基本过程在环境被支持, 也有途径创建自己的过程<br/>另有种数据类型<code>port</code>端口, 关联文件和终端的输入输出<br/>比如<code>display</code>还有个隐含的参数, 表示输出的端口<br/><code>(display "Hello, World!" (current-output-port)</code><br/><br/><code>scm</code>解释器会探测每一个形式<code>(form)</code>首个符号<br/>如果那是过程, 就会将其余作为参数执行这个形式<br/>像<code>begin define set!</code>是一些特殊形式, 特殊行为<br/>用户可以通过<code>lambda</code>表达式创建过程<br/><pre><code>(lambda (x) (+ x 2))<br/>((lambda (x) (+ x 2)) 5) ;=&gt; 7<br/>(define add2 (lambda (x) (+ x 2)))<br/>(add2 4) ;=&gt; 6<br/>(define area<br/>	(lambda (length breadth)<br/>		(* length breadth)))<br/>(define area *) ;=&gt; 同上</code></pre><code>apply</code>可以运行一个过程, 并载入指定参数<br/>可以载入多个参数, 但必须要列表作为参数结尾<br/><pre><code>(define x '(1 2 3))<br/>(apply + x) ;=&gt; 2<br/>(apply + 1 2 3 x) ;=&gt; 12</code></pre><code>begin</code>用来俺顺序执行参数中的子形式<br/>而<code>lambda</code>内部也是顺序执行的:<br/><pre><code>(define display3<br/>	(lambda (arg1 arg2)<br/>		(display arg1)<br/>		(newline)<br/>		(display arg2))</code></pre><br/>条件语句<code>if</code>, <code>else</code>是隐含的<br/><pre><code>(if #t<br/>	(display "true"))<br/>(if (&gt; 1 0)<br/>	(display "true")<br/>	(display "false"))</code></pre><code>when</code>用来判断, 当为真, 按顺序执行子形式<br/><code>unelss</code>把<code>when</code>的条件取反, 然后顺序执行<br/>不过两者在<code>guile</code>里用不出来, 不考虑了<br/><code>cond</code>用于判别, 每个参数都有判别是和结果<br/>有可选的<code>else</code>, 相似有<code>case</code>, 看例子的括号<br/><pre><code>(define c #\c)<br/>(cond ((char&lt;? c #\c) -1)<br/>	((char=? c #\c) 0)<br/>	(else 1)) ;=&gt; 0<br/>(case c<br/>	((#\a) 1)<br/>	((#\c) 2)<br/>	(else 3))</code></pre><code>and or not</code>对应: 且, 或, 非<br/>不过在<code>guile</code>对于多个值或其他类型参数就要出错<br/><pre><code>(and #\t #\f) ;=&gt; #\f<br/>(or #\t #\f) ;=&gt; #\t</code></pre><br/><p><b><code>scm</code>的变量作用域是词法域, 静态作用域</b></p>全局变量不受局部变量的影响, 看例子<br/><pre><code>(define x 9)<br/>(define add 2 (lambda (x) (+ x 2)))<br/>x ;=&gt; 9<br/>(add2 3) ;=&gt; 5<br/>x ;=&gt; 9</code></pre>而<code>(set! x 20)</code>能对全局变量进行修改<br/><code>scm</code>会选取词法上(?)最近的变量进行使用<br/><pre><code>(define counter 0)<br/>(define bump-counter<br/>	(lambda ()<br/>		(set! counter (+ counter 1))<br/>		counter))<br/>(bump-counter) ;=&gt; 1<br/>(bump-counter) ;=&gt; 2</code></pre><code>let</code>可以新建局部变量, 遮盖全局变量, 注意写法<br/><pre><code>(define x 20)<br/>(let (<br/>	(x 1)<br/>	(y 2))<br/>	(list x y)) ;=&gt; (1 2)<br/>(let (<br/>	(x 1)<br/>	(y x))<br/>	(list x y)) ;=&gt; (1 20)</code></pre>考虑到<code>let*</code>还有下面的写法<br/><pre><code>(let* ((x 1)<br/>	(y x))<br/>	(+ x y)) ;=&gt; 2<br/>(let ((x 1))<br/>	(let ((x y))<br/>		(+ x y))) ;=&gt; 2<br/>(let ((cons (lambda (x y) (+ x y))))<br/>	(cons 1 2)) ;=&gt; 3</code></pre><code>fluid-let</code>会临时修改全局变量值, 过后复原<br/>但是这个在<code>guile</code>里头也是不对劲的(?)<br/>而<code>let</code>本身面对这样的过程处理不同<br/><pre><code>(define x 0)<br/>(define x+<br/>	(lambda ()<br/>		(set! x (+ x 1))<br/>		(display x)))<br/>(let ((x 20))<br/>	(x+)) ;=&gt; 1</code></pre><br/><p><b>递归, 调用自身, 转化条件, 设定边界, 看例子</b></p><pre><code>(define fractorial<br/>	lambda (n)<br/>		(if (= n) 1<br/>			(* n (fractorial (- n 1)))))<br/>(define is-even?<br/>	(lambda (n)<br/>		(if (= n 0) #t<br/>			(is-odd? (- n 1)))))<br/>(define is-odd?<br/>	(lambda (n)<br/>		(if (= n 0) #f<br/>			(is-even? (- n 1)))))</code></pre>其实<code>scm</code>已经内置<code>even? odd?</code>两个过程<br/>注意在局部变量实现<code>is-even? is-odd?</code>会有问题<br/>用<code>let</code>时<code>if</code>内部的<code>is-even? is-odd?</code>不能正确指向<br/>用<code>let*</code>时<code>if</code>内部的<code>is-odd</code>不能正确指向<br/>于是引入了新的过程<code>letrec</code>进行<br/><pre><code>(letrec ((local-even? (lambda (n)<br/>	(if (= n 0) #t<br/>		(local-odd? (- n 1)))))<br/>	(local-odd? (lambda (n)<br/>		(if (= n 0) #f<br/>			(local-even? (- n 1))))))<br/>	(list (local-even? 23) (local-odd? 23)))</code></pre><code>letrec</code>是专门为定义递归和相互递归的局部过程设计的<br/>借助<code>letrec</code>实现的循环过程<br/><pre><code>(letrec ((countdown (lambda (i)<br/>	(if (= i 0) 'liftoff<br/>		(begin<br/>			(display i)<br/>			(newline)<br/>			(countdown (- i 1)))))))<br/>	(countdown 10))</code></pre>这一段可以用宏用<code>let</code>写更紧凑的结构<br/><pre><code>(let countdown ((i 10))<br/>	(if (= i 0) 'liftoff<br/>		(begin<br/>			(display i)<br/>			(newline)<br/>			(countdown (- i 1)))))</code></pre><code>scm</code>中不存在递归以外其他循环和迭代的构造<br/>递归会被关照以免开销过大(?)<br/>前面的递归是尾部递归, 尾递归可以被优化, 因而安全<br/>例子, 尾递归实现, 从列表<code>l</code>取元素<code>o</code>位置, 否则返回<code>#f</code><br/>例子, 递归倒转列表内容的顺序<br/><pre><code>(define reverse!<br/>	(lambda (s)<br/>		(let loop ((s s) (r '()))<br/>			(if (null? s) r<br/>				(let ((d (cdr s)))<br/>					(set-cdr! s r)<br/>					(display d)<br/>					(display ", ")<br/>					(display s)<br/>					(newline)<br/>					(loop d s))))))</code></pre>几个小时才看明白, 还好环境里一般会提供这个函数的<br/>有一类迭代多次重复, 就是遍历列表每个元素<br/>于是有<code>map for-each</code>两种操作, 前者熟悉的<br/><pre><code>(define add2 (lambda (x)<br/>	(+ x 2)))<br/>(map add2 '(1 2 3)) ;=&gt; (3 4 5)<br/>(map cons '(1 2 3) '(10 20 30)) ;=&gt; ((1 .10) (2 . 20) (3 30))<br/>(map + '(1 2 3) '(10 20 30)) ;=&gt; ( 11 22 33)</code></pre>而后者没有返回值, 是副作用<br/><pre><code>(for-each display '(1 2 3 4))</code></pre><br/><code>scm</code>的读取端口的参数是可选的, 默认是<code>console</code><br/>读取内容以字符, 行, <code>S 表达式</code>为单位<br/>以某种<code>EOF</code>结束, 才能用<code>eof-object?</code>判断结束<br/>函数有<code>read-char read-line read</code>, 后者读取<code>S 表达式</code><br/>写入的端口也是可选的, 默认<code>console</code><br/>写入的单位可以是字符, 或者基于<code>S 表达式</code><br/><code>write-char</code>写出的时候不会有<code>#\</code>前置, 保留机器方便的格式<br/><code>display</code>的功能类似, 但会更方便人们阅读<br/><code>open-input-file</code>过程接收文件名, 返回输出端口<br/><pre><code>(define i (open-input-file "hello.txt"))<br/>(read-char i) ;=&gt; #\h<br/>(define j (read i))<br/>j ;=&gt; ello</code></pre>如果原文件不存在, <code>close-output-file</code>会建立新文件<br/>运行代码发现<code>output input file port</code>易混淆, 注意<br/><pre><code>(define o (open-output-file "g.txt"))<br/>(display "hello" o)<br/>(write-char #\space o)<br/>(display 'world o)<br/>(newline o)<br/>(close0output-port o)</code></pre><code>call-with-input-file</code>和<code>call-with-output-file</code>自动管理关闭<br/><pre><code>(call-with-input-file "hello.txt"<br/>	(lambda (i)<br/>		(let* ((a (read-char i))<br/>			(b (read-char i))<br/>			(c (read-char i)))<br/>		(list a b c)))) ;=&gt; (#\h #\e #\l)</code></pre>未来操作字符串方便有<code>open-input-string open-output-string</code><br/><pre><code>(define i (open-input-string "hello world"))<br/>(read-char i) ;=&gt; #\h<br/>(read i) ;=&gt; ello<br/>(read i) ;=&gt; world<br/>(define o (open-output-string))<br/>(write 'hello o)<br/>(write-char #\, o)<br/>(display " " o)<br/>(display "world" o)<br/>(get-output-string o) ;=&gt; "hello, world"</code></pre>还有<code>load load-ralative</code>两个形式, 解说比较复杂(?)<br/><br/>宏按说明应该像重用的代码块的缩写之类, 像链接用<br/><pre><code>(defint-macro when<br/>	(lambda (test . branch)<br/>		(list 'if test<br/>			(cons 'begin branch)))))</code></pre>用<code>define-macro</code>定义, 结果是<br/><pre><code>(when (&lt; 1 2)<br/>	(display "true 1\n")<br/>	(display "true 2\n"))</code></pre>相当于代入其中转化成为<br/><pre><code>(if (&lt; 1 2)<br/>	(begin<br/>		(display "true 1\n")<br/>		(display "true 2\n")))</code></pre>同样有<code>unless</code>的使用, 甚至在其中使用已经定义的<code>when</code><br/><pre><code>(define-macro unless<br/>	(lambda (test . branch)<br/>		(list 'if<br/>			(list 'not test)<br/>			(cons 'begin branch))))<br/>(define-macro unless<br/>	(lambda (test . branch)<br/>		(cons 'when<br/>			(cons (list 'not test) branch))))</code></pre>用反引号还可以简化语法, 大概<code>guile</code>对大小写敏感<br/>其中<code>,</code>表示插入相应的值, <code>,@</code>表示插入相应<code>S 表达式</code><br/><pre><code>(defin-macro when<br/>	(lambda (test . branch)<br/>		`(if ,test<br/>			(begin ,@branch))))</code></pre>当用下面这种方式实现一个<code>or</code>形式<br/><pre><code>(define-macro my-or<br/>	(lambda (x y)<br/>		`(if ,x ,x ,y)))<br/>(my-or 1 2) ;=&gt; 1<br/>(my-or #f 2) ;=&gt; 2<br/>(my-or<br/>	(begin<br/>		(display "twice")<br/>		(newline)<br/>		#t)<br/>	2)</code></pre>上面因为求值过程, 会出现两次<code>display</code>, 改写<br/><pre><code>(define-macro my-or<br/>	(lambda (x y)<br/>		`(let ((temp ,x))<br/>			(if temp temp ,y))))</code></pre>再改写用来形成私有的调用, 甚至用<code>gensym</code>产生私有的符号<br/><pre><code>(define-macro my-or<br/>	(lambda (x y)<br/>		`(let ((+temp ,x))<br/>			(if +temp +temp ,y))))<br/>(define-macro my-or<br/>	(lambda (x y)<br/>		(lat ((temp (gensym)))<br/>			`(let ((,temp ,x))<br/>				(if ,temp ,temp ,y)))))</code></pre><code>? 8.3 的 fluid-let 在 guile 没有, 正好跳过</code><br/><br/>后边<code>Mzscheme</code>和<code>guile</code>差别较大, 加上难度, 放弃了<br/><br/>